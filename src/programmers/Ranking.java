package programmers;


import java.util.*;
class Ranking {
    public int solution(int n, int[][] results) {
        int answer = 0;
        //선수의 수 100명 이하 1명이상
        //경기경과 4500개이하 1개이상
        //순위를 매길 수 있다. --> 자신을 제외한 선수들의 수만큼 정보가 있다.
        //각 선수당 경기결과를 돌아다니면서 자신이 이기는 결과와 지는 결과의 수를 다 더해서 n-1개 있으면 되는거 아닐가?
        //그런데 n-1개 있는 선수가 있을 때 그 선수를 기준으로
        //만약 그 선수 순위가 3위면 4위의 선수는 3위 선수에게 지고 5위선수에게 이기면 되는 구조다.
        //각 선수당 자신이 포함된 경기 결과의 개수를 봐보자.
        //그런데 12 23 34 45이렇게 해도 12345순위가 매겨지긴한다.
        //유니온 파인드인가..?
        //1의 자식은 2 3 4 5
        //2의 자식은 3 4 5
        //3의 자식은 4 5
        //4의 자식은 5
        //5의 자식은 없다.

        //근데 유니온 파인드도 자신을 이기는 부모를 찾아줄 뿐이지 자기를 이기는 명수와
        //자기한테 지는 명수를 온전히 찾아주긴 힘들다.
        //각 선수가 경기결과를 찾아보는데, 자기한테 이기는 선수가 또 누굴 이기는지도 찾아야하고
        //자기한테 지는 선수가 또 누구한테 지는지도 찾아야한다.
        //마치 논리가 a가 b한테 지고 b가 c한테도 진다면 a는 c한테도 반드시 진다.
        //이런 누가 누구한테 지냐 이기냐라는 사실의 존재가 유무가 중요하다.
        //어쨋든 지냐 이기냐의 사실의 합이 n-1이면 그 선수의 순위를 알 수 있다.
        int[][] arr = new int[n + 1][n + 1];

        for (int i = 0; i < results.length ; i++){
            int winner = results[i][0];
            int loser = results[i][1];
            arr[loser][winner] = -1;
            arr[winner][loser] = 1;
        }

        for(int i = 0; i < n + 1; i++){
            for(int j = 0; j < n + 1; j++){
                for(int k = 0; k < n + 1; k++){
                    if (arr[i][k] == 1 && arr[k][j] == 1){
                        arr[i][j] = 1;
                        arr[j][i] = -1;
                    }
                    if (arr[i][k] == -1 && arr[k][j] == -1){
                        arr[i][j] = -1;
                        arr[j][i] = 1;
                    }
                }
            }
        }

        for(int i = 0; i < n + 1; i++){
            int cnt = 0;
            for (int j = 0; j < n + 1; j++){
                if(arr[i][j] != 0){
                    cnt += 1;
                }
            }
            if (cnt == n - 1){
                answer += 1;
            }
        }

        return answer;
    }


}
